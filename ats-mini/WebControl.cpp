/**
 * WebControl.cpp - REST API + SSE Web Remote Control
 * 
 * Implements a web-based remote control interface for the ATS-Mini radio.
 * 
 * THREAD SAFETY: ESPAsyncWebServer runs callbacks in a separate FreeRTOS task.
 * The SI4735 radio chip communicates via I2C which is NOT thread-safe.
 * Therefore, all radio operations (rx.*) MUST happen in the main loop() task.
 * 
 * The API handlers only set pending commands in a queue. The webControlProcessCommands()
 * function (called from loop()) processes the queue and performs the actual
 * radio operations safely. webControlBroadcastStatus() handles SSE updates separately
 * to avoid delaying command processing.
 */

#include "WebControl.h"
#include "Common.h"
#include "Menu.h"
#include "Storage.h"
#include "Utils.h"

#include <freertos/FreeRTOS.h>
#include <freertos/portmacro.h>
#include <new>  // for std::nothrow

// External functions defined in ats-mini.ino
extern bool doTune(int16_t enc);
extern bool doSeek(int16_t enc, int16_t enca);

// External function defined in Menu.cpp
extern bool tuneToMemory(const Memory *memory);

// Check if we have the embedded HTML (generated by build script)
#if __has_include("control_html.h")
#include "control_html.h"
#define HAS_EMBEDDED_HTML 1
#define CONTROL_PAGE_GZ_MAX 16384
// RAM copy so response is sent from RAM (avoids PROGMEM async read issues)
static uint8_t s_controlPageGz[CONTROL_PAGE_GZ_MAX];
static size_t s_controlPageGzLen = 0;
#else
#define HAS_EMBEDDED_HTML 0
#endif

//=============================================================================
// Constants
//=============================================================================

#define BROADCAST_INTERVAL_MS    50   // Max 20 updates/second for snappier RSSI/SNR
#define BROADCAST_MAX_CLIENTS   3     // Limit simultaneous SSE clients
#define JSON_STATUS_SIZE        768   // Status JSON buffer size
#define JSON_OPTIONS_SIZE       4096  // Options JSON buffer size

//=============================================================================
// Command Queue (thread-safe: written by async task, read by main loop)
//=============================================================================

enum WebCmdType : uint8_t
{
  WEB_CMD_NONE = 0,
  WEB_CMD_TUNE_DIR,       // param1 = direction (+1/-1)
  WEB_CMD_TUNE_FREQ,      // param1 = frequency, param2 = bfo
  WEB_CMD_SEEK,           // param1 = direction (+1/-1)
  WEB_CMD_VOLUME,         // param1 = value (0-63)
  WEB_CMD_SQUELCH,        // param1 = value (0-127)
  WEB_CMD_AGC,            // param1 = value (0 = auto)
  WEB_CMD_AVC,            // param1 = value (12-90)
  WEB_CMD_BAND,           // param1 = band index
  WEB_CMD_MODE,           // param1 = direction (+1/-1)
  WEB_CMD_MODE_SET,       // param1 = mode index (0=FM, 1=LSB, 2=USB, 3=AM)
  WEB_CMD_STEP,           // param1 = direction (+1/-1)
  WEB_CMD_BANDWIDTH,      // param1 = direction (+1/-1)
  WEB_CMD_MUTE,           // param1 = 1 mute, 0 unmute
  WEB_CMD_MEMORY_TUNE,    // param1 = slot index
  WEB_CMD_SCAN_START,     // start full band scan (blocking)
  WEB_CMD_SCAN_EXIT,      // exit band scan mode
  WEB_CMD_RDS_MODE,       // param1 = rdsModeIdx (0=PS, 6=All EU)
};

#define CMD_QUEUE_SIZE 24
#define BATCH_WINDOW_MS 75  // Time window for batching similar commands (75ms)

struct WebCommand
{
  WebCmdType cmd;
  int16_t param1;
  int16_t param2;
};

static volatile WebCommand cmdQueue[CMD_QUEUE_SIZE];
static volatile uint8_t cmdQueueHead = 0;  // Write index (async task)
static volatile uint8_t cmdQueueTail = 0;  // Read index (main loop)
static portMUX_TYPE cmdQueueMux = portMUX_INITIALIZER_UNLOCKED;

// Batching tracking: last enqueue time and queue index per batchable command type
// Indexed by (cmdType - WEB_CMD_VOLUME) for batchable commands only
static volatile uint32_t lastBatchTime[7];  // Last enqueue time per batchable cmd type
static volatile uint8_t lastBatchIndex[7];  // Queue index of last batched cmd (0xFF = not in queue)

// Check if command type is batchable (replace old with new within time window)
static bool isBatchable(WebCmdType cmd)
{
  return (cmd == WEB_CMD_VOLUME || cmd == WEB_CMD_SQUELCH || cmd == WEB_CMD_AGC ||
          cmd == WEB_CMD_AVC || cmd == WEB_CMD_TUNE_FREQ || cmd == WEB_CMD_MUTE ||
          cmd == WEB_CMD_MODE_SET);
}

// Get batch tracking index for a batchable command type
static uint8_t getBatchIndex(WebCmdType cmd)
{
  switch(cmd)
  {
    case WEB_CMD_VOLUME: return 0;
    case WEB_CMD_SQUELCH: return 1;
    case WEB_CMD_AGC: return 2;
    case WEB_CMD_AVC: return 3;
    case WEB_CMD_TUNE_FREQ: return 4;
    case WEB_CMD_MUTE: return 5;
    case WEB_CMD_MODE_SET: return 6;
    default: return 0xFF;  // Invalid
  }
}

// Check if a queue index is still valid (not yet processed)
static bool isIndexInQueue(uint8_t idx)
{
  // Handle circular buffer wrapping
  if(cmdQueueTail <= cmdQueueHead)
  {
    // Normal case: tail <= head
    return (idx >= cmdQueueTail && idx < cmdQueueHead);
  }
  else
  {
    // Wrapped case: head < tail
    return (idx >= cmdQueueTail || idx < cmdQueueHead);
  }
}

// Enqueue a command (called from async task). When full, drop oldest so latest intent is never lost.
// Batches similar commands: if same batchable command type enqueued within BATCH_WINDOW_MS,
// replaces the previous command's params instead of adding new entry.
static bool cmdEnqueue(WebCmdType cmd, int16_t p1 = 0, int16_t p2 = 0)
{
  portENTER_CRITICAL(&cmdQueueMux);
  
  uint32_t now = millis();
  
  // Check if this command is batchable and if we should batch it
  if(isBatchable(cmd))
  {
    uint8_t batchIdx = getBatchIndex(cmd);
    if(batchIdx != 0xFF)
    {
      uint32_t lastTime = lastBatchTime[batchIdx];
      uint8_t lastIdx = lastBatchIndex[batchIdx];
      
      // If same command type was enqueued within window and still in queue, replace it
      if((now - lastTime) < BATCH_WINDOW_MS && lastIdx != 0xFF && isIndexInQueue(lastIdx))
      {
        // Replace params at the existing queue position
        cmdQueue[lastIdx].param1 = p1;
        cmdQueue[lastIdx].param2 = p2;
        // Update time but keep same index
        lastBatchTime[batchIdx] = now;
        portEXIT_CRITICAL(&cmdQueueMux);
        return true;
      }
      // Otherwise, enqueue normally and update tracking
    }
  }
  
  // Normal enqueue path (non-batchable or no recent duplicate found)
  uint8_t nextHead = (cmdQueueHead + 1) % CMD_QUEUE_SIZE;
  if(nextHead == cmdQueueTail)
  {
    // Drop oldest - invalidate batch tracking if it pointed to the dropped index
    uint8_t droppedIdx = cmdQueueTail;
    for(int i = 0; i < 7; i++)
    {
      if(lastBatchIndex[i] == droppedIdx)
        lastBatchIndex[i] = 0xFF;  // Invalidate
    }
    cmdQueueTail = (cmdQueueTail + 1) % CMD_QUEUE_SIZE;  // Drop oldest
  }

  cmdQueue[cmdQueueHead].cmd = cmd;
  cmdQueue[cmdQueueHead].param1 = p1;
  cmdQueue[cmdQueueHead].param2 = p2;
  
  // Update batch tracking if batchable
  if(isBatchable(cmd))
  {
    uint8_t batchIdx = getBatchIndex(cmd);
    if(batchIdx != 0xFF)
    {
      lastBatchTime[batchIdx] = now;
      lastBatchIndex[batchIdx] = cmdQueueHead;
    }
  }
  
  cmdQueueHead = nextHead;
  portEXIT_CRITICAL(&cmdQueueMux);
  return true;
}

// Dequeue a command (called from main loop)
static bool cmdDequeue(WebCommand &out)
{
  portENTER_CRITICAL(&cmdQueueMux);
  if(cmdQueueTail == cmdQueueHead)
  {
    portEXIT_CRITICAL(&cmdQueueMux);
    return false;  // Queue empty
  }
  out.cmd = cmdQueue[cmdQueueTail].cmd;
  out.param1 = cmdQueue[cmdQueueTail].param1;
  out.param2 = cmdQueue[cmdQueueTail].param2;
  
  // Invalidate batch tracking if this was a tracked batchable command
  if(isBatchable(out.cmd))
  {
    uint8_t batchIdx = getBatchIndex(out.cmd);
    if(batchIdx != 0xFF && lastBatchIndex[batchIdx] == cmdQueueTail)
    {
      lastBatchIndex[batchIdx] = 0xFF;  // Mark as no longer in queue
    }
  }
  
  cmdQueueTail = (cmdQueueTail + 1) % CMD_QUEUE_SIZE;
  portEXIT_CRITICAL(&cmdQueueMux);
  return true;
}

//=============================================================================
// SSE Event Source
//=============================================================================

static AsyncEventSource events("/events");

//=============================================================================
// Broadcast State
//=============================================================================

static bool statusDirty = false;
static uint32_t lastBroadcast = 0;

// Cached stereo state (updated in main loop, safe to read from async task)
static volatile bool cachedStereo = false;

// Previous state for change detection
static uint16_t prevFreq = 0;
static int16_t prevBFO = 0;
static uint8_t prevRssi = 0;
static uint8_t prevSnr = 0;
static uint8_t prevVol = 0;
static uint8_t prevSql = 0;
static uint8_t prevAgc = 0;
static uint8_t prevBand = 0;
static uint8_t prevMode = 0;
static uint8_t prevStepIdx = 0;
static uint8_t prevBwIdx = 0;
static bool prevInScanMode = false;
static bool prevScanHasData = false;
static bool prevMute = false;
static bool prevSeeking = false;
static int prevRdsModeIdx = -1;

// Seek direction when in seek mode (for status JSON)
static int8_t webSeekDirection = 0;

//=============================================================================
// Helper: Escape JSON string
//=============================================================================

static void jsonEscapeString(char *dest, const char *src, size_t maxLen)
{
  if(!dest || maxLen == 0) return;
  if(!src) { dest[0] = '\0'; return; }
  
  size_t j = 0;
  for(size_t i = 0; src[i] && j < maxLen - 1; i++)
  {
    char c = src[i];
    if(c == '"' || c == '\\')
    {
      if(j < maxLen - 2) { dest[j++] = '\\'; dest[j++] = c; }
    }
    else if(c >= 32)
    {
      dest[j++] = c;
    }
  }
  dest[j] = '\0';
}

//=============================================================================
// JSON Builders (read-only access to globals - safe from any task)
// Note: rx.getCurrentPilot() replaced with cachedStereo to avoid I2C call
//=============================================================================

static String buildStatusJSON()
{
  char json[JSON_STATUS_SIZE];
  char stationBuf[64] = "";
  char radioTextBuf[128] = "";
  char bandNameBuf[16] = "";
  char stepDescBuf[8] = "";
  char bwDescBuf[8] = "";
  
  Band *band = getCurrentBand();
  const char *station = getStationName();
  const char *radioText = getRadioText();
  
  // Escape all strings for JSON safety
  jsonEscapeString(bandNameBuf, band->bandName, sizeof(bandNameBuf));
  jsonEscapeString(stepDescBuf, getCurrentStep()->desc, sizeof(stepDescBuf));
  jsonEscapeString(bwDescBuf, getCurrentBandwidth()->desc, sizeof(bwDescBuf));
  jsonEscapeString(stationBuf, station, sizeof(stationBuf));
  jsonEscapeString(radioTextBuf, radioText, sizeof(radioTextBuf));
  
  // AGC max depends on mode
  uint8_t agcMax = currentMode == FM ? 27 : isSSB() ? 1 : 37;
  
  // AVC value (not available in FM)
  int8_t avcVal = currentMode == FM ? 0 : isSSB() ? SsbAvcIdx : AmAvcIdx;
  
  snprintf(json, sizeof(json),
    "{"
    "\"freq\":%u,"
    "\"bfo\":%d,"
    "\"band\":%d,"
    "\"bandName\":\"%s\","
    "\"mode\":%d,"
    "\"modeName\":\"%s\","
    "\"rssi\":%u,"
    "\"snr\":%u,"
    "\"vol\":%u,"
    "\"sql\":%u,"
    "\"agc\":%d,"
    "\"agcMax\":%u,"
    "\"agcAuto\":%s,"
    "\"avc\":%d,"
    "\"avcAvail\":%s,"
    "\"stepIdx\":%d,"
    "\"stepDesc\":\"%s\","
    "\"bwIdx\":%d,"
    "\"bwDesc\":\"%s\","
    "\"stereo\":%s,"
    "\"station\":\"%s\","
    "\"radioText\":\"%s\","
    "\"inScanMode\":%s,"
    "\"scanHasData\":%s,"
    "\"mute\":%s,"
    "\"seeking\":%s,"
    "\"seekDirection\":%d,"
    "\"rdsModeIdx\":%d"
    "}",
    currentFrequency,
    currentBFO,
    bandIdx,
    bandNameBuf,
    currentMode,
    bandModeDesc[currentMode],
    rssi,
    snr,
    volume,
    currentSquelch,
    agcIdx,
    agcMax,
    agcIdx == 0 ? "true" : "false",
    avcVal,
    currentMode != FM ? "true" : "false",
    band->currentStepIdx,
    stepDescBuf,
    band->bandwidthIdx,
    bwDescBuf,
    cachedStereo ? "true" : "false",
    stationBuf,
    radioTextBuf,
    currentCmd == CMD_SCAN ? "true" : "false",
    scanHasData() ? "true" : "false",
    muteOn(MUTE_MAIN) ? "true" : "false",
    currentCmd == CMD_SEEK ? "true" : "false",
    (int)webSeekDirection,
    (int)getRDSModeIdx()
  );
  
  return String(json);
}

static String buildOptionsJSON()
{
  String json;
  json.reserve(JSON_OPTIONS_SIZE);
  
  json = "{\"version\":\"";
  json += getVersion(false);
  json += "\",";
  
  // Bands array
  json += "\"bands\":[";
  int totalBands = getTotalBands();
  for(int i = 0; i < totalBands; i++)
  {
    if(i > 0) json += ",";
    json += "{\"idx\":";
    json += i;
    json += ",\"name\":\"";
    json += bands[i].bandName;
    json += "\",\"mode\":";
    json += bands[i].bandMode;
    json += ",\"min\":";
    json += bands[i].minimumFreq;
    json += ",\"max\":";
    json += bands[i].maximumFreq;
    json += "}";
  }
  json += "],";
  
  // Band map (broadcast/amateur segments in kHz; must match Draw.cpp getBandMapType for signal scale)
  json += "\"bandMap\":{\"broadcast\":[";
  json += "[520,1602],[2300,2500],[3200,3400],[3900,4000],[4750,5060],[5800,6325],[7200,7450],[9400,9900],[11600,12100],[13570,13870],[15100,15800]";
  json += "],\"amateur\":[";
  json += "[1810,2000],[3500,3800],[5250,5450],[7000,7200],[10100,10150],[14000,14530]";
  json += "]},";

  // Modes array
  json += "\"modes\":[";
  int totalModes = getTotalModes();
  for(int i = 0; i < totalModes; i++)
  {
    if(i > 0) json += ",";
    json += "\"";
    json += bandModeDesc[i];
    json += "\"";
  }
  json += "],";
  
  // AGC max values per mode
  json += "\"agcMax\":{\"FM\":27,\"SSB\":1,\"AM\":37},";
  
  // Limits
  json += "\"volumeMax\":63,";
  json += "\"squelchMax\":127,";
  json += "\"avcMin\":12,";
  json += "\"avcMax\":90,";
  json += "\"memorySlots\":";
  json += getTotalMemories();
  
  json += "}";
  
  return json;
}

static String buildMemoriesJSON()
{
  String json;
  json.reserve(2048);
  
  json = "[";
  int totalMem = getTotalMemories();
  for(int i = 0; i < totalMem; i++)
  {
    if(i > 0) json += ",";
    json += "{\"slot\":";
    json += i;
    json += ",\"freq\":";
    json += memories[i].freq;
    json += ",\"band\":";
    json += memories[i].band;
    json += ",\"mode\":";
    json += memories[i].mode;
    json += ",\"name\":\"";
    char nameBuf[16];
    jsonEscapeString(nameBuf, memories[i].name, sizeof(nameBuf));
    json += nameBuf;
    json += "\"}";
  }
  json += "]";
  
  return json;
}

//=============================================================================
// Command Processors (called from main loop - safe to use rx.*)
//=============================================================================

static void processSetVolume(uint8_t val)
{
  volume = min(val, (uint8_t)63);
  if(!muteOn(MUTE_MAIN)) rx.setVolume(volume);
}

static void processSetSquelch(uint8_t val)
{
  currentSquelch = min(val, (uint8_t)127);
}

static void processSetAgc(uint8_t val)
{
  uint8_t maxVal = currentMode == FM ? 27 : isSSB() ? 1 : 37;
  val = min(val, maxVal);
  
  if(currentMode == FM)
    FmAgcIdx = val;
  else if(isSSB())
    SsbAgcIdx = val;
  else
    AmAgcIdx = val;
  
  agcIdx = val;
  disableAgc = val > 0 ? 1 : 0;
  agcNdx = val > 1 ? val - 1 : 0;
  rx.setAutomaticGainControl(disableAgc, agcNdx);
}

static void processSetAvc(uint8_t val)
{
  if(currentMode == FM) return;
  
  val = constrain(val, 12, 90);
  val = (val / 2) * 2;  // Round to step of 2
  
  if(isSSB())
    SsbAvcIdx = val;
  else
    AmAvcIdx = val;
  
  rx.setAvcAmMaxGain(val);
}

static void processSetFrequency(uint16_t freq, int16_t bfo)
{
  Band *band = getCurrentBand();
  freq = constrain(freq, band->minimumFreq, band->maximumFreq);
  
  clearStationInfo();
  
  // Set BFO first if SSB
  if(bfo && isSSB())
    updateBFO(bfo, false);
  
  // Set frequency
  rx.setFrequency(freq);
  
  // Clear BFO if not SSB
  if(!isSSB() && currentBFO)
    updateBFO(0, true);
  
  currentFrequency = rx.getFrequency();
  band->currentFreq = currentFrequency + currentBFO / 1000;
  
  identifyFrequency(currentFrequency + currentBFO / 1000);
}

static void processSelectBand(uint8_t idx)
{
  if(idx >= getTotalBands()) return;
  
  // Save current band settings
  bands[bandIdx].currentFreq = currentFrequency + currentBFO / 1000;
  bands[bandIdx].bandMode = currentMode;
  
  selectBand(idx);
}

static void processSetMute(bool mute)
{
  muteOn(MUTE_MAIN, mute);
}

// Process one command from the queue (called from main loop)
static void processCommand(const WebCommand &cmd)
{
  switch(cmd.cmd)
  {
    case WEB_CMD_TUNE_DIR:
      doTune(cmd.param1 > 0 ? 1 : -1);
      prefsRequestSave(SAVE_CUR_BAND);
      break;
      
    case WEB_CMD_TUNE_FREQ:
      processSetFrequency((uint16_t)cmd.param1, cmd.param2);
      prefsRequestSave(SAVE_CUR_BAND);
      break;
      
    case WEB_CMD_SEEK:
    {
      int16_t dir = cmd.param1 > 0 ? 1 : -1;
      webSeekDirection = (int8_t)dir;
      doSeek(dir, dir);
      prefsRequestSave(SAVE_CUR_BAND);
      break;
    }
      
    case WEB_CMD_VOLUME:
      processSetVolume((uint8_t)cmd.param1);
      break;
      
    case WEB_CMD_SQUELCH:
      processSetSquelch((uint8_t)cmd.param1);
      break;
      
    case WEB_CMD_AGC:
      processSetAgc((uint8_t)cmd.param1);
      break;
      
    case WEB_CMD_AVC:
      processSetAvc((uint8_t)cmd.param1);
      break;
      
    case WEB_CMD_BAND:
      processSelectBand((uint8_t)cmd.param1);
      prefsRequestSave(SAVE_CUR_BAND);
      break;
      
    case WEB_CMD_MODE:
      if(currentMode != FM)
      {
        doMode(cmd.param1 > 0 ? 1 : -1);
        prefsRequestSave(SAVE_CUR_BAND);
      }
      break;
      
    case WEB_CMD_MODE_SET:
    {
      uint8_t midx = (uint8_t)cmd.param1;
      // VHF is band 0: only mode 0 (FM). Other bands: only 1=LSB, 2=USB, 3=AM
      if(bandIdx == 0 && midx != 0) break;
      if(bandIdx != 0 && (midx == 0 || midx > 3)) break;
      bands[bandIdx].bandMode = midx;
      selectBand(bandIdx);
      prefsRequestSave(SAVE_CUR_BAND);
    }
    break;
      
    case WEB_CMD_STEP:
      doStep(cmd.param1 > 0 ? 1 : -1);
      break;
      
    case WEB_CMD_BANDWIDTH:
      doBandwidth(cmd.param1 > 0 ? 1 : -1);
      break;
      
    case WEB_CMD_MUTE:
      processSetMute(cmd.param1 != 0);
      break;
      
    case WEB_CMD_MEMORY_TUNE:
      if(cmd.param1 >= 0 && cmd.param1 < getTotalMemories() && memories[cmd.param1].freq)
      {
        tuneToMemory(&memories[cmd.param1]);
        prefsRequestSave(SAVE_CUR_BAND);
      }
      break;
      
    case WEB_CMD_SCAN_START:
      currentCmd = CMD_SCAN;
      clearStationInfo();
      rssi = snr = 0;
      scanRun(currentFrequency, 10);
      break;
      
    case WEB_CMD_SCAN_EXIT:
      currentCmd = CMD_NONE;
      break;
      
    case WEB_CMD_RDS_MODE:
      setRDSModeIdx((uint8_t)constrain(cmd.param1, 0, 7));
      prefsRequestSave(SAVE_SETTINGS);
      break;
      
    default:
      break;
  }
  
  statusDirty = true;
}

//=============================================================================
// Response Helpers
//=============================================================================

static void sendOK(AsyncWebServerRequest *request)
{
  request->send(200, "application/json", "{\"ok\":true}");
}

static void sendError(AsyncWebServerRequest *request, int code, const char *message)
{
  char json[128];
  snprintf(json, sizeof(json), "{\"ok\":false,\"error\":\"%s\"}", message);
  request->send(code, "application/json", json);
}

//=============================================================================
// API Handlers - GET
//=============================================================================

static void handleGetOptions(AsyncWebServerRequest *request)
{
  request->send(200, "application/json", buildOptionsJSON());
}

static void handleGetStatus(AsyncWebServerRequest *request)
{
  request->send(200, "application/json", buildStatusJSON());
}

static void handleGetMemories(AsyncWebServerRequest *request)
{
  request->send(200, "application/json", buildMemoriesJSON());
}

static void handleGetScan(AsyncWebServerRequest *request)
{
  if(!scanHasData())
  {
    request->send(404, "application/json", "{\"ok\":false,\"error\":\"No scan data\"}");
    return;
  }
  uint16_t startFreq = scanGetStartFreq();
  uint16_t step = scanGetStep();
  uint16_t count = scanGetCount();
  if(count == 0)
  {
    request->send(404, "application/json", "{\"ok\":false,\"error\":\"No scan data\"}");
    return;
  }
  String json;
  json.reserve(1600);
  json = "{\"startFreq\":";
  json += startFreq;
  json += ",\"step\":";
  json += step;
  json += ",\"count\":";
  json += count;
  json += ",\"points\":[";
  for(uint16_t i = 0; i < count; i++)
  {
    if(i > 0) json += ",";
    json += "{\"rssi\":";
    json += scanGetPointRSSI(i);
    json += ",\"snr\":";
    json += scanGetPointSNR(i);
    json += "}";
  }
  json += "]}";
  request->send(200, "application/json", json);
}

//=============================================================================
// JSON Parser Helpers
//=============================================================================

static bool jsonGetInt(const char *json, const char *key, int &value)
{
  char searchKey[32];
  snprintf(searchKey, sizeof(searchKey), "\"%s\":", key);
  
  const char *pos = strstr(json, searchKey);
  if(!pos) return false;
  
  pos += strlen(searchKey);
  while(*pos == ' ') pos++;
  
  if(strncmp(pos, "true", 4) == 0) { value = 1; return true; }
  if(strncmp(pos, "false", 5) == 0) { value = 0; return true; }
  
  if(*pos == '-' || (*pos >= '0' && *pos <= '9'))
  {
    value = atoi(pos);
    return true;
  }
  
  return false;
}

static bool jsonGetBool(const char *json, const char *key, bool &value)
{
  int intVal;
  if(jsonGetInt(json, key, intVal))
  {
    value = (intVal != 0);
    return true;
  }
  return false;
}

//=============================================================================
// Body Handler (collects body, processes in handleRequest)
//=============================================================================

class BodyHandler : public AsyncWebHandler
{
public:
  String _uri;
  WebRequestMethodComposite _method;
  std::function<void(AsyncWebServerRequest*, const char*)> _handler;
  
  BodyHandler(const char *uri, WebRequestMethodComposite method,
              std::function<void(AsyncWebServerRequest*, const char*)> handler)
    : _uri(uri), _method(method), _handler(handler) {}
  
  bool canHandle(AsyncWebServerRequest *request) const override
  {
    if(request->method() != _method) return false;
    if(request->url() != _uri) return false;
    return true;
  }
  
  // Collect body data into request's _tempObject
  void handleBody(AsyncWebServerRequest *request, uint8_t *data, size_t len,
                  size_t index, size_t total) override
  {
    // Only handle single-chunk bodies under 512 bytes
    if(total > 512) return;
    
    if(index == 0)
    {
      // Allocate buffer for body
      char *buf = new (std::nothrow) char[total + 1];
      if(!buf) return;
      buf[0] = '\0';
      request->_tempObject = buf;
    }
    
    // Copy data
    if(request->_tempObject)
    {
      char *buf = (char *)request->_tempObject;
      memcpy(buf + index, data, len);
      if(index + len == total)
        buf[total] = '\0';
    }
  }
  
  // Process the collected body
  void handleRequest(AsyncWebServerRequest *request) override
  {
    if(request->_tempObject)
    {
      const char *body = (const char *)request->_tempObject;
      _handler(request, body);
      delete[] (char *)request->_tempObject;
      request->_tempObject = nullptr;
    }
    else
    {
      sendError(request, 400, "No body");
    }
  }
};

//=============================================================================
// POST Handlers (enqueue commands - NO rx.* calls!)
//=============================================================================

static void handleTune(AsyncWebServerRequest *request, const char *body)
{
  int freq, bfo = 0, direction;
  
  if(jsonGetInt(body, "freq", freq))
  {
    jsonGetInt(body, "bfo", bfo);
    if(cmdEnqueue(WEB_CMD_TUNE_FREQ, (int16_t)freq, (int16_t)bfo))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else if(jsonGetInt(body, "direction", direction))
  {
    if(cmdEnqueue(WEB_CMD_TUNE_DIR, direction > 0 ? 1 : -1))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else
  {
    sendError(request, 400, "Missing freq or direction");
  }
}

static void handleSeek(AsyncWebServerRequest *request, const char *body)
{
  bool stopSeek = false;
  if(jsonGetBool(body, "stop", stopSeek) && stopSeek)
  {
    seekStop = true;  // Stops seek or scan (checked in main loop)
    sendOK(request);
    return;
  }
  int direction = 1;
  jsonGetInt(body, "direction", direction);
  
  if(cmdEnqueue(WEB_CMD_SEEK, direction > 0 ? 1 : -1))
    sendOK(request);
  else
    sendError(request, 503, "Command queue full");
}

static void handleScan(AsyncWebServerRequest *request, const char *body)
{
  if(body && strstr(body, "\"action\":\"stop\""))
  {
    seekStop = true;  // Stops running scan (same as seek stop)
    sendOK(request);
    return;
  }
  if(body && strstr(body, "\"action\":\"exit\""))
  {
    if(cmdEnqueue(WEB_CMD_SCAN_EXIT))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
    return;
  }
  if(body && strstr(body, "\"action\":\"start\""))
  {
    if(cmdEnqueue(WEB_CMD_SCAN_START))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
    return;
  }
  sendError(request, 400, "Missing action (start|stop|exit)");
}

static void handleVolume(AsyncWebServerRequest *request, const char *body)
{
  int value;
  if(jsonGetInt(body, "value", value))
  {
    if(cmdEnqueue(WEB_CMD_VOLUME, (int16_t)value))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else
  {
    sendError(request, 400, "Missing value");
  }
}

static void handleSquelch(AsyncWebServerRequest *request, const char *body)
{
  int value;
  if(jsonGetInt(body, "value", value))
  {
    if(cmdEnqueue(WEB_CMD_SQUELCH, (int16_t)value))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else
  {
    sendError(request, 400, "Missing value");
  }
}

static void handleAgc(AsyncWebServerRequest *request, const char *body)
{
  bool autoAgc;
  int value;
  
  if(jsonGetBool(body, "auto", autoAgc) && autoAgc)
  {
    if(cmdEnqueue(WEB_CMD_AGC, 0))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else if(jsonGetInt(body, "value", value))
  {
    if(cmdEnqueue(WEB_CMD_AGC, (int16_t)value))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else
  {
    sendError(request, 400, "Missing value or auto");
  }
}

static void handleAvc(AsyncWebServerRequest *request, const char *body)
{
  int value;
  if(jsonGetInt(body, "value", value))
  {
    if(cmdEnqueue(WEB_CMD_AVC, (int16_t)value))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else
  {
    sendError(request, 400, "Missing value");
  }
}

static void handleBand(AsyncWebServerRequest *request, const char *body)
{
  int index;
  if(jsonGetInt(body, "index", index))
  {
    if(index >= 0 && index < getTotalBands())
    {
      if(cmdEnqueue(WEB_CMD_BAND, (int16_t)index))
        sendOK(request);
      else
        sendError(request, 503, "Command queue full");
    }
    else
    {
      sendError(request, 400, "Invalid band index");
    }
  }
  else
  {
    sendError(request, 400, "Missing index");
  }
}

static void handleMode(AsyncWebServerRequest *request, const char *body)
{
  int modeIndex = -1;
  if(jsonGetInt(body, "mode", modeIndex) && modeIndex >= 0 && modeIndex <= 3)
  {
    if(cmdEnqueue(WEB_CMD_MODE_SET, (int16_t)modeIndex))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
    return;
  }
  
  int direction = 1;
  jsonGetInt(body, "direction", direction);
  
  if(currentMode == FM)
  {
    sendError(request, 400, "Cannot change mode in FM");
    return;
  }
  
  if(cmdEnqueue(WEB_CMD_MODE, direction > 0 ? 1 : -1))
    sendOK(request);
  else
    sendError(request, 503, "Command queue full");
}

static void handleStep(AsyncWebServerRequest *request, const char *body)
{
  int direction = 1;
  jsonGetInt(body, "direction", direction);
  
  if(cmdEnqueue(WEB_CMD_STEP, direction > 0 ? 1 : -1))
    sendOK(request);
  else
    sendError(request, 503, "Command queue full");
}

static void handleBandwidth(AsyncWebServerRequest *request, const char *body)
{
  int direction = 1;
  jsonGetInt(body, "direction", direction);
  
  if(cmdEnqueue(WEB_CMD_BANDWIDTH, direction > 0 ? 1 : -1))
    sendOK(request);
  else
    sendError(request, 503, "Command queue full");
}

static void handleMute(AsyncWebServerRequest *request, const char *body)
{
  bool mute;
  if(jsonGetBool(body, "mute", mute))
  {
    if(cmdEnqueue(WEB_CMD_MUTE, mute ? 1 : 0))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else
  {
    sendError(request, 400, "Missing mute");
  }
}

static void handleRds(AsyncWebServerRequest *request, const char *body)
{
  int mode = -1;
  if(jsonGetInt(body, "mode", mode) && mode >= 0 && mode <= 7)
  {
    if(cmdEnqueue(WEB_CMD_RDS_MODE, (int16_t)mode))
      sendOK(request);
    else
      sendError(request, 503, "Command queue full");
  }
  else
  {
    sendError(request, 400, "Missing or invalid mode (0-7)");
  }
}

//=============================================================================
// Memory API Handlers
//=============================================================================

static int parseMemorySlot(AsyncWebServerRequest *request)
{
  if(!request->hasParam("slot")) return -1;
  
  String slotStr = request->getParam("slot")->value();
  
  for(size_t i = 0; i < slotStr.length(); i++)
  {
    if(!isDigit(slotStr[i])) return -1;
  }
  
  if(slotStr.length() == 0) return -1;
  
  return slotStr.toInt();
}

static void handleMemoryStore(AsyncWebServerRequest *request)
{
  int slot = parseMemorySlot(request);
  
  if(slot < 0 || slot >= getTotalMemories())
  {
    sendError(request, 400, "Invalid or missing slot parameter");
    return;
  }
  
  // Store to memory (no I2C calls needed - just writing memory struct)
  memories[slot].freq = (currentMode == FM) ?
    (uint32_t)currentFrequency * 10000 :
    (uint32_t)(currentFrequency * 1000 + currentBFO);
  memories[slot].band = bandIdx;
  memories[slot].mode = currentMode;
  memset(memories[slot].name, 0, sizeof(memories[slot].name));
  
  prefsRequestSave(SAVE_MEMORIES);
  sendOK(request);
}

static void handleMemoryTune(AsyncWebServerRequest *request)
{
  int slot = parseMemorySlot(request);
  
  if(slot < 0 || slot >= getTotalMemories())
  {
    sendError(request, 400, "Invalid or missing slot parameter");
    return;
  }
  
  if(memories[slot].freq == 0)
  {
    sendError(request, 400, "Memory slot is empty");
    return;
  }
  
  // Enqueue - actual tuning happens in main loop
  if(cmdEnqueue(WEB_CMD_MEMORY_TUNE, (int16_t)slot))
    sendOK(request);
  else
    sendError(request, 503, "Command queue full");
}

static void handleMemoryClear(AsyncWebServerRequest *request)
{
  int slot = parseMemorySlot(request);
  
  if(slot < 0 || slot >= getTotalMemories())
  {
    sendError(request, 400, "Invalid or missing slot parameter");
    return;
  }
  
  // Clear memory (no I2C calls)
  memories[slot].freq = 0;
  memories[slot].band = 0;
  memories[slot].mode = 0;
  memset(memories[slot].name, 0, sizeof(memories[slot].name));
  
  prefsRequestSave(SAVE_MEMORIES);
  sendOK(request);
}

//=============================================================================
// SSE Broadcast State
//=============================================================================

static bool hasStateChanged()
{
  return statusDirty ||
         prevFreq != currentFrequency ||
         prevBFO != currentBFO ||
         prevRssi != rssi ||
         prevSnr != snr ||
         prevVol != volume ||
         prevSql != currentSquelch ||
         prevAgc != agcIdx ||
         prevBand != bandIdx ||
         prevMode != currentMode ||
         prevStepIdx != bands[bandIdx].currentStepIdx ||
         prevBwIdx != bands[bandIdx].bandwidthIdx ||
         prevInScanMode != (currentCmd == CMD_SCAN) ||
         prevScanHasData != scanHasData() ||
         prevMute != muteOn(MUTE_MAIN) ||
         prevSeeking != (currentCmd == CMD_SEEK) ||
         prevRdsModeIdx != (int)getRDSModeIdx();
}

static void updatePrevState()
{
  prevFreq = currentFrequency;
  prevBFO = currentBFO;
  prevRssi = rssi;
  prevSnr = snr;
  prevVol = volume;
  prevSql = currentSquelch;
  prevAgc = agcIdx;
  prevBand = bandIdx;
  prevMode = currentMode;
  prevStepIdx = bands[bandIdx].currentStepIdx;
  prevBwIdx = bands[bandIdx].bandwidthIdx;
  prevInScanMode = (currentCmd == CMD_SCAN);
  prevScanHasData = scanHasData();
  prevMute = muteOn(MUTE_MAIN);
  prevSeeking = (currentCmd == CMD_SEEK);
  prevRdsModeIdx = (int)getRDSModeIdx();
  statusDirty = false;
}

//=============================================================================
// Public Functions
//=============================================================================

void webControlProcessCommands()
{
  // Process ALL pending commands immediately (safe - runs in main loop)
  WebCommand cmd;
  while(cmdDequeue(cmd))
  {
    processCommand(cmd);
  }
  
  // Update cached stereo state (needed for status JSON, safe I2C call from main loop)
  if(currentMode == FM)
    cachedStereo = rx.getCurrentPilot();
  else
    cachedStereo = false;
}

void webControlBroadcastStatus()
{
  // Throttle SSE broadcasts
  uint32_t now = millis();
  if((now - lastBroadcast) < BROADCAST_INTERVAL_MS) return;
  
  if(!hasStateChanged()) return;
  
  if(events.count() > 0)
  {
    String json = buildStatusJSON();
    events.send(json.c_str(), "status", millis());
  }
  
  updatePrevState();
  lastBroadcast = now;
}

void webControlTick()
{
  // Combined function for backward compatibility
  // Processes commands immediately, then broadcasts status if throttled time passed
  webControlProcessCommands();
  webControlBroadcastStatus();
}

void webControlNotify()
{
  statusDirty = true;
}

uint8_t webControlClientCount()
{
  return events.count();
}

void webControlInit(AsyncWebServer &server)
{
  // Initialize batch tracking arrays
  for(int i = 0; i < 7; i++)
  {
    lastBatchTime[i] = 0;
    lastBatchIndex[i] = 0xFF;  // 0xFF = not in queue
  }
  
  // SSE endpoint
  events.onConnect([](AsyncEventSourceClient *client)
  {
    if(events.count() > BROADCAST_MAX_CLIENTS)
    {
      client->close();
      return;
    }
    
    // Send current state on connect (reads cached globals, no I2C)
    client->send(buildStatusJSON().c_str(), "status", millis());
  });
  server.addHandler(&events);
  
  // GET endpoints (read-only, no I2C calls)
  server.on("/api/options", HTTP_GET, handleGetOptions);
  server.on("/api/status", HTTP_GET, handleGetStatus);
  server.on("/api/memories", HTTP_GET, handleGetMemories);
  server.on("/api/scan", HTTP_GET, handleGetScan);
  
  // POST endpoints with body (commands queued for main loop)
  server.addHandler(new BodyHandler("/api/tune", HTTP_POST, handleTune));
  server.addHandler(new BodyHandler("/api/seek", HTTP_POST, handleSeek));
  server.addHandler(new BodyHandler("/api/scan", HTTP_POST, handleScan));
  server.addHandler(new BodyHandler("/api/volume", HTTP_POST, handleVolume));
  server.addHandler(new BodyHandler("/api/squelch", HTTP_POST, handleSquelch));
  server.addHandler(new BodyHandler("/api/agc", HTTP_POST, handleAgc));
  server.addHandler(new BodyHandler("/api/avc", HTTP_POST, handleAvc));
  server.addHandler(new BodyHandler("/api/band", HTTP_POST, handleBand));
  server.addHandler(new BodyHandler("/api/mode", HTTP_POST, handleMode));
  server.addHandler(new BodyHandler("/api/step", HTTP_POST, handleStep));
  server.addHandler(new BodyHandler("/api/bandwidth", HTTP_POST, handleBandwidth));
  server.addHandler(new BodyHandler("/api/mute", HTTP_POST, handleMute));
  server.addHandler(new BodyHandler("/api/rds", HTTP_POST, handleRds));
  
  // Memory endpoints (query params, no body needed)
  server.on("/api/memory/store", HTTP_POST, handleMemoryStore);
  server.on("/api/memory/tune", HTTP_POST, handleMemoryTune);
  server.on("/api/memory/clear", HTTP_POST, handleMemoryClear);
  
  // Serve control page (copy from PROGMEM to RAM at init so async send reads from RAM)
#if HAS_EMBEDDED_HTML
  if(control_html_gz_len > 0 && control_html_gz_len <= CONTROL_PAGE_GZ_MAX)
  {
    memcpy_P(s_controlPageGz, control_html_gz, control_html_gz_len);
    s_controlPageGzLen = control_html_gz_len;
  }
  
  server.on("/control", HTTP_GET, [](AsyncWebServerRequest *request)
  {
#if HAS_EMBEDDED_HTML
    if(s_controlPageGzLen > 0)
    {
      AsyncWebServerResponse *response = request->beginResponse(
        200, "text/html", s_controlPageGz, s_controlPageGzLen);
      response->addHeader("Content-Encoding", "gzip");
      response->addHeader("Cache-Control", "no-cache");
      request->send(response);
    }
    else
#endif
    {
      request->send(200, "text/html",
        "<!DOCTYPE html><html><head><title>ATS-Mini Control</title></head>"
        "<body style='font-family:sans-serif;text-align:center;padding:50px'>"
        "<h1>ATS-Mini Web Control</h1>"
        "<p>Control page not available.</p>"
        "<p><a href='/api/status'>/api/status</a></p>"
        "</body></html>");
    }
  });
#else
  server.on("/control", HTTP_GET, [](AsyncWebServerRequest *request)
  {
    request->send(200, "text/html",
      "<!DOCTYPE html><html><head><title>ATS-Mini Control</title></head>"
      "<body style='font-family:sans-serif;text-align:center;padding:50px'>"
      "<h1>ATS-Mini Web Control</h1>"
      "<p>Embedded HTML not available.</p>"
      "<p>Use <a href='/api/status'>/api/status</a> for API access.</p>"
      "</body></html>");
  });
#endif
}
